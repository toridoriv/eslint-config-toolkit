import { is } from "#predicates";
import type { AnyArray, AnyFunction, AnyObject, KeyOf, Merge } from "#typings";

/**
 * Merges two objects into a new object.
 *
 * If a key exists in both objects, the value from the second object will be used.
 * If a key exists in only one object, its value will be used.
 * If a key exists in both objects and the values are arrays, they will be concatenated.
 * If a key exists in both objects and the values are objects, they will be merged recursively.
 *
 * @param a
 * @param b
 * @returns
 */
export function merge<T extends AnyObject, U extends AnyObject>(a: T, b: U): Merge<T, U> {
  if (!is.object(a) || !is.object(b)) {
    throw new TypeError("Both arguments must be objects.");
  }

  const result = {} as Merge<T, U>;
  const keys = getUnique<(KeyOf<T> | KeyOf<U>)[]>(Object.keys(a).concat(Object.keys(b)));

  for (const key of keys) {
    const value = merge.any(a[key], b[key]);
    const descriptor = is.defined(b[key])
      ? Object.getOwnPropertyDescriptor(b, key)
      : Object.getOwnPropertyDescriptor(a, key);

    replaceValue(result as any, key, descriptor, value);
  }

  return result;
}

merge.any = function mergeAny(a: any, b: any) {
  if (!is.defined(a)) return clone(b);
  if (!is.defined(b)) return clone(a);
  if (is.array(a) && is.array(b)) return merge.array(a, b);
  if (is.object(a) && is.object(b)) return merge(a, b);

  return clone(b);
};

merge.array = function mergeArray<T extends AnyArray, U extends AnyArray>(a: T, b: U): T & U {
  return [...a, ...b] as T & U;
};

export function coerce<T = any>(value: unknown) {
  return value as T;
}

export function pick<T, K extends PropertyKey>(obj: T, key: K): K extends keyof T ? T[K] : undefined {
  return obj[key as unknown as keyof T] as K extends keyof T ? T[K] : undefined;
}

export function getUnique<T extends AnyArray>(list: T): T {
  return Array.from(new Set(list)) as T;
}

export function clone<T>(value: T): T {
  if (is.primitive(value)) return value;
  if (is.array(value)) return value.map(clone) as T;
  if (is.function(value)) return clone.function(value) as T;
  if (is.object(value)) return clone.object({}, value) as T;

  throw new TypeError("Unsupported type for cloning.");
}

clone.function = function cloneFunction<T extends AnyFunction>(fn: T): T {
  let body = fn.toString();

  if (!is.arrowFunction(fn) && !body.startsWith("function")) {
    body = `function ${body}`;
  }

  const name = fn.name || "anonymous";

  const result = new Function("return " + body)();

  Object.defineProperty(result, "name", {
    value: name,
    writable: false,
    configurable: true,
  });

  return clone.object(result, fn) as T;
};

clone.object = function cloneObject<T extends object>(receiver: object, obj: T): T {
  if (!is.object(obj) && !is.function(obj)) {
    throw new TypeError("Argument must be an object or a function.", {
      cause: {
        received: {
          value: obj,
          type: is.typeOf(obj),
        },
      },
    });
  }

  for (const key in obj) {
    if (!(key in receiver)) {
      const descriptors = Object.getOwnPropertyDescriptor(obj, key);

      Object.defineProperty(receiver, key, {
        ...descriptors,
        value: clone(obj[key]),
      });
    }
  }

  return receiver as T;
};

export function replaceValue<T extends object, K extends keyof T>(
  obj: T,
  key: K,
  descriptor?: PropertyDescriptor,
  value?: unknown,
): T {
  if (!is.object(obj)) {
    throw new TypeError("First argument must be an object.");
  }

  if (!descriptor) {
    Object.getOwnPropertyDescriptor(obj, key) as PropertyDescriptor;
  }

  return Object.defineProperty(obj, key, {
    ...descriptor,
    value,
  });
}
